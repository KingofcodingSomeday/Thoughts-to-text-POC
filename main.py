# -*- coding: utf-8 -*-
"""EEG Spectrogram Analysis & Classification

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z3It1HHtxio_RIFj0aZUtAR_C9be8Nhu
"""

#Importing libraries
"""import os

os.environ["KERAS_BACKEND"] = "tensorflow"

from glob import glob
import tensorflow as tf
import keras
from keras import layers
import math
os.mkdir('analysis')
import matplotlib.pyplot as plt

import numpy as np
import pandas as pd
from scipy.signal import spectrogram
import time
from skimage.measure import block_reduce
fs = 256 # For Muse sampling rate

from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.preprocessing import StandardScaler
from keras.models import Sequential
from tensorflow.keras.layers import Activation, BatchNormalization, Conv2D, Dense, Flatten, MaxPooling2D, Dropout
import matplotlib.pyplot as plt
from keras.utils import to_categorical
import seaborn as snNew
import matplotlib.pyplot as pltNew
from muselsl import record
import joblib

# Creating spectrograms with function 'GetSpectrogramsForEEGData' which requires the eeg data file
def GetSpectrogramsForEEGData(eeg_data):
  #convert to spectrograms for each class
  segment_length = 1  # seconds
  frame_length = segment_length * fs

  f, t, Sxx1 = spectrogram(eeg_data.iloc[:, 1], fs=256, nperseg=frame_length, noverlap=0)
  f, t, Sxx2 = spectrogram(eeg_data.iloc[:, 2], fs=256, nperseg=frame_length, noverlap=0)
  f, t, Sxx3 = spectrogram(eeg_data.iloc[:, 3], fs=256, nperseg=frame_length, noverlap=0)
  f, t, Sxx4 = spectrogram(eeg_data.iloc[:, 4], fs=256, nperseg=frame_length, noverlap=0)

  # Concatenate the spectrograms (Combine the 4 spectrograms for 4 channels into one image for CNN)
  Sxx = np.concatenate((Sxx1, Sxx2, Sxx3, Sxx4))

  label_index = 5 #Label is in the last column
  flattened_spectrogram = Sxx.flatten() #Flatten the spectrogram

# Each section is 256 rows. This means that when using the Muse headset (with sampling frequency of 256hz,
# only 1 second of data is required. This should be tested with delay and interferences.)
  labels = eeg_data.iloc[:, label_index]
  labels = block_reduce(labels, block_size=(256), func=np.mean, cval=np.mean(labels))
  labels = labels[0:np.shape(Sxx)[1]]
  labels = np.round(labels)
  Sxx = np.transpose(Sxx)

  # Function returns an array containing the amplitude and the labels
  return (Sxx,labels)

#read in data file containing the complete dataset of three classes (for now)
eeg_data = pd.read_csv("LatinN_O_neutral_dataset1.csv")

#separate classes
Sxx, labels = GetSpectrogramsForEEGData(eeg_data)

# Assigning the x values (the amplitudes)
x = Sxx

# Assigning the y values (labels)
y = labels

# Splitting Data into train and test
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

# Scale Data
scaler = StandardScaler()
x_train_scaled = scaler.fit_transform(x_train)
x_test_scaled = scaler.transform(x_test)

dropoutProb = 0.5 # Drop 50% of the data when commanded to
# Build the model
model = Sequential() # Using a sequential model
model.add(Dense(2048, activation='relu', input_dim=x_train_scaled.shape[1])) # First layer has 2038 neurons
model.add(Dropout(dropoutProb))
model.add(Dense(2048, activation='relu'))
model.add(Dropout(dropoutProb))
model.add(Dense(2048, activation='relu'))
model.add(Dropout(dropoutProb))
model.add(Dense(3,  activation='softmax')) # Output layer with one neuron for binary classification

# Compile the data
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
y_train_onehot = to_categorical(y_train)
y_test_onehot = to_categorical(y_test)
# Train the model
model.fit(x_train_scaled, y_train_onehot, epochs=40, batch_size=32, validation_data=(x_test_scaled, y_test_onehot))

# Evaluate the model
accuracy = model.evaluate(x_test_scaled, y_test_onehot)[1]
print(f'Test Accuracy: {accuracy * 100:.2f}%')
predictions = model.predict(x_test_scaled)
binary_predictions = np.argmax(predictions,axis=-1)
cm = confusion_matrix(y_test, binary_predictions)
print(cm)
snNew.heatmap(cm, annot=True)
pltNew.show()

plt.pcolormesh(np.transpose(Sxx), shading='gouraud', cmap='viridis',vmin=0, vmax=1)
#plt.colorbar() color bar disabled.
plt.show();

plt.plot(labels)
plt.show();

#test the model on the 3 test sets

#read in data file
eeg_data_LatinN1 = pd.read_csv("UnfilteredTest_LatinN1_V_LatinO1_V_Neutral.csv")
#separate classes
Sxx, labels = GetSpectrogramsForEEGData(eeg_data_LatinN1)
y_test_LatinN1 =labels
x_test_LatinN1 = Sxx
x_test_scaled = scaler.transform(x_test_LatinN1)
y_test_LatinN1_onehot = to_categorical(y_test_LatinN1)

# Evaluate the model
accuracy = model.evaluate(x_test_scaled, y_test_LatinN1_onehot)[1]
print(f'Test Accuracy: {accuracy * 100:.2f}%')
predictions = model.predict(x_test_scaled)
binary_predictions = np.argmax(predictions,axis=-1)
cm = confusion_matrix(y_test_LatinN1, binary_predictions)
print(cm)
snNew.heatmap(cm, annot=True)
pltNew.show()

"""

